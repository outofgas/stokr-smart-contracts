pragma solidity 0.4.24;

import "../node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol";
import "../node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "../node_modules/zeppelin-solidity/contracts/math/SafeMath.sol";


/// @title ProfitSharing
/// @author Autogenerated from a Dia UML diagram
contract ProfitSharing is Ownable {

    using SafeMath for uint;

    struct InvestorAccount {
        uint balance;
        uint lastTotalProfits;
        uint profitShare;
    }

    mapping(address => InvestorAccount) public accounts;

    address public profitDepositor;
    address public profitDistributor;
    uint public totalProfits;

    // As long as the total supply isn't fixed, i.e. new tokens can appear out of thin air,
    // the investors' profit shares aren't determined.
    bool public totalSupplyIsFixed;
    uint internal totalSupply_;

    event ProfitDepositorChange(address indexed newProfitDepositor);

    event ProfitDistributorChange(address indexed newProfitDistributor);

    /// @dev Log entry on profit deposited
    /// @param depositor An Ethereum address
    /// @param amount A positive number
    event ProfitDeposit(address indexed depositor, uint amount);

    /// @dev Log entry on profit share updated
    /// @param investor An Ethereum address
    /// @param amount A positive number
    event ProfitShareUpdate(address indexed investor, uint amount);

    /// @dev Log entry on profit withdrawal
    /// @param investor An Ethereum address
    /// @param amount A positive number
    event ProfitShareWithdrawal(address indexed investor, address indexed beneficiary, uint amount);

    /// @dev Ensure only depositor
    modifier onlyProfitDepositor() {
        require(msg.sender == profitDepositor, "Operation is restricted to profit depositor.");
        _;
    }

    /// @dev Ensure only distributor
    modifier onlyProfitDistributor() {
        require(msg.sender == profitDepositor, "Operation is restricted to profit distributor.");
        _;
    }

    /// @dev Constructor
    /// @param _profitDepositor An Ethereum address
    constructor(address _profitDepositor) public {
        setProfitDepositor(_profitDepositor);
    }

    /// @dev Fallback function
    function() public payable {
        depositProfit();
    }

    /// @dev Change profit depositor
    /// @param _newProfitDepositor An Ethereum address
    function setProfitDepositor(address _newProfitDepositor) public onlyOwner {
        require(_newProfitDepositor != address(0x0), "Profit depositor address must not be zero.");

        // Don't emit event if set for first time or to the same value again
        if (profitDepositor != address(0x0) && _newProfitDepositor != profitDepositor) {
            emit ProfitDepositorChange(_newProfitDepositor);
        }
        profitDepositor = _newProfitDepositor;
    }

    /// @dev Change profit distributor
    /// @param _newProfitDistributor An Ethereum address
    function setProfitDistributor(address _newProfitDistributor) public onlyOwner {
        require(_newProfitDistributor != address(0x0), "Profit distributor address must not be zero.");

        // Don't emit event if set for first time or to the same value again
        if (profitDistributor != address(0x0) && _newProfitDistributor != profitDistributor) {
            emit ProfitDistributorChange(_newProfitDistributor);
        }
        profitDistributor = _newProfitDistributor;
    }

    /// @dev Deposit profit
    function depositProfit() public payable onlyProfitDepositor {
        totalProfits = totalProfits.add(msg.value);

        emit ProfitDeposit(msg.sender, msg.value);
    }

    /// @dev Profit share owing
    /// @param _investor An Ethereum address
    /// @return A positive number
    function profitShareOwing(address _investor) public view returns (uint) {
        if (!totalSupplyIsFixed || totalSupply_ == 0) {
            return 0;
        }
        return totalProfits.sub(accounts[_investor].lastTotalProfits)
                           .mul(accounts[_investor].balance)
                           .div(totalSupply_);  // <- The linter doesn't like this.
    }

    /// @dev Update profit share
    /// @param _investor An Ethereum address
    function updateProfitShare(address _investor) public {
        require(totalSupplyIsFixed, "Total supply must be fixed prior to update profit share.");

        uint additionalProfitShare = profitShareOwing(_investor);

        accounts[_investor].lastTotalProfits = totalProfits;
        accounts[_investor].profitShare = accounts[_investor].profitShare.add(additionalProfitShare);

        emit ProfitShareUpdate(_investor, additionalProfitShare);
    }

    /// @dev Withdraw profit share
    function withdrawProfitShare() public {
        _withdrawProfitShare(msg.sender, msg.sender);
    }

    function withdrawProfitShare(address _beneficiary) public {
        _withdrawProfitShare(msg.sender, _beneficiary);
    }

    /// @dev Withdraw profit share
    function withdrawProfitShares(address[] _investors) public onlyProfitDistributor {
        for (uint i = 0; i < _investors.length; ++i) {
            _withdrawProfitShare(_investors[i], _investors[i]);
        }
    }

    /// @dev Withdraw profit share
    function _withdrawProfitShare(address _investor, address _beneficiary) internal {
        updateProfitShare(_investor);

        uint withdrawnProfitShare = accounts[_investor].profitShare;

        accounts[_investor].profitShare = 0;
        _beneficiary.transfer(withdrawnProfitShare);

        emit ProfitShareWithdrawal(_investor, _beneficiary, withdrawnProfitShare);
    }

}

