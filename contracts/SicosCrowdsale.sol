pragma solidity 0.4.24;

import "../zeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol";
import "./MintableToken.sol";


/// @title SicosCrowdsale
/// @author Autogenerated from a Dia UML diagram
contract SicosCrowdsale is RefundableCrowdsale {

    uint totalTokenCap;
    uint remainingTokenAmount;

    address public teamAccount;
    uint public teamShare;

    /// @dev Log entry on rate changed
    /// @param oldRate A positive number
    /// @param newRate A positive number
    event RateChanged(uint oldRate, uint newRate);

    /// @dev Crowdsale
    /// @param _token An Ethereum address
    /// @param _tokenCap A positive number
    /// @param _tokenGoal A positive number
    /// @param _openingTime A positive number
    /// @param _closingTime A positive number
    /// @param _rate A positive number
    /// @param _wallet An Ethereum address
    constructor(MintableToken _token,
                uint _tokenCap,
                uint _tokenGoal,
                uint _openingTime,
                uint _closingTime,
                uint _rate,
                uint _teamShare,
                address _wallet)
        public
        RefundableCrowdsale(_tokenGoal)
        TimedCrowdsale(_openingTime, _closingTime)
        Crowdsale(_rate, _wallet, _token)
    {
        require(_teamShare <= _tokenCap);
        require(_tokenGoal <= _tokenCap - _teamShare);

        totalTokenCap = _tokenCap;
        remainingTokenAmount = _tokenCap - _teamShare;
        teamShare = _teamShare;
    }

    /// @dev Distribute presold tokens.
    /// @param _accounts List of Ethereum addresses who will receive tokens
    /// @param _amounts List of token amounts per account
    function distributePresoldTokens(address[] _accounts, uint[] _amounts) public onlyOwner {
        require(_accounts.length == _amounts.length);

        for (uint i = 0; i < _accounts.length; ++i) {
            _deliverTokens(_accounts[i], _amounts[i]);
        }
    }

    /// @dev Set rate
    /// @param _newRate A positive number
    function setRate(uint _newRate) public onlyOwner {
        // A rate change by an order of magnitude (or more) is likely a typo instead of intention
        // Note, this implicitly ensures the new rate cannot be set to zero
        require(rate / 10 < _newRate && _newRate < 10 * rate);

        if (_newRate != rate) {
            emit RateChanged(rate, _newRate);
        }
        rate = _newRate;
    }

    /// @dev Set team account
    /// @param _teamAccount An Ethereum address.
    function setTeamAccount(address _teamAccount) public onlyOwner {
        require(_teamAccount != address(0x0));

        teamAccount = _teamAccount;
    }

    /// @dev Remaining time of open crowdsale.
    /// @return Remaining time in seconds, or 0 if crowdsale has ended.
    function remaingingTime() public view returns (uint) {
        if (now >= closingTime) {
            return 0;
        }

        return closingTime - now;
    }

    /// @dev Overridden RefundableCrowdsale.goalReached().
    /// @return Wether the desired token amount was sold
    function goalReached() public view returns (bool) {
        return totalTokenCap - teamShare - remainingTokenAmount >= goal;
    }

    /// @dev Extend parent behavior requiring beneficiary to be identical to msg.sender
    /// @param _beneficiary Token purchaser
    /// @param _weiAmount Amount of wei contributed
    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
        require(_beneficiary == msg.sender);

        super._preValidatePurchase(_beneficiary, _weiAmount);
    }

    /// @dev Extend parent behavior by minting a tokens for the benefit of beneficiary.
    /// @param _beneficiary Token recipient
    /// @param _tokenAmount Token amount
    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(remainingTokenAmount >= _tokenAmount);

        remainingTokenAmount -= _tokenAmount;

        MintableToken(token).mint(_beneficiary, _tokenAmount);
    }

    /// @dev Extend parent behavior to finish the token minting.
    function finalization() internal {
        require(teamAccount != address(0x0));

        super.finalization();

        MintableToken(token).mint(teamAccount, teamShare);
        MintableToken(token).finishMinting();
    }

}
