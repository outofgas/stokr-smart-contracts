pragma solidity 0.4.24;

import "../node_modules/zeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol";
import "./SicosToken.sol";


/// @title SicosCrowdsale
/// @author Autogenerated from a Dia UML diagram
contract SicosCrowdsale is RefundableCrowdsale {

    uint public tokenCap;
    uint public tokenRemaining;

    address public teamAccount;
    uint public teamShare;

    /// @dev Log entry on rate changed
    /// @param oldRate A positive number
    /// @param newRate A positive number
    event RateChanged(uint oldRate, uint newRate);

    /// @dev Constructor
    /// @param _token Address of token contract
    /// @param _tokenCap Maximum amount of token (sale + share)
    /// @param _tokenGoal Minimum amount of sold tokens for a successful sale
    /// @param _openingTime Unix timestamp of crowdsale opening
    /// @param _closingTime Unix timestamp of crowdsale closing
    /// @param _rate Tokens per ether rate
    /// @param _wallet Multisig wallet for receiving invested ether
    constructor(SicosToken _token,
                uint _tokenCap,
                uint _tokenGoal,
                uint _openingTime,
                uint _closingTime,
                uint _rate,
                uint _teamShare,
                address _wallet)
        public
        RefundableCrowdsale(_tokenGoal)
        TimedCrowdsale(_openingTime, _closingTime)
        Crowdsale(_rate, _wallet, _token)
    {
        require(_teamShare <= _tokenCap, "Team share must not exceed token cap.");
        require(_tokenGoal <= _tokenCap - _teamShare, "Goal must be attainable.");

        tokenCap = _tokenCap;
        teamShare = _teamShare;
        tokenRemaining = _tokenCap - _teamShare;

        _token.setMinter(this);
    }

    /// @dev Distribute tokens.
    /// @param _accounts List of Ethereum addresses who will receive tokens
    /// @param _amounts List of token amounts per account
    function distributeTokens(address[] _accounts, uint[] _amounts) public onlyOwner {
        require(_accounts.length == _amounts.length, "Number of accounts and amounts must be equal.");

        for (uint i = 0; i < _accounts.length; ++i) {
            _deliverTokens(_accounts[i], _amounts[i]);
        }
    }

    /// @dev Set rate
    /// @param _newRate A positive number
    function setRate(uint _newRate) public onlyOwner {
        // A rate change by an order of magnitude (or more) is likely a typo instead of intention
        // Note, this implicitly ensures the new rate cannot be set to zero
        require(rate / 10 < _newRate && _newRate < 10 * rate, "Rate change must be less than an order of magnitude.");

        if (_newRate != rate) {
            emit RateChanged(rate, _newRate);
        }
        rate = _newRate;
    }

    /// @dev Set team account
    /// @param _teamAccount An Ethereum address.
    function setTeamAccount(address _teamAccount) public onlyOwner {
        require(_teamAccount != address(0x0), "Team account address must not be zero.");

        teamAccount = _teamAccount;
    }

    /// @dev Time remaining of open crowdsale.
    /// @return Duration in seconds, or 0 if crowdsale has ended.
    function timeRemaining() public view returns (uint) {
        if (now >= closingTime) {
            return 0;
        }

        return closingTime - now;
    }

    /// @dev Overridden RefundableCrowdsale.goalReached().
    /// @return Whether the desired token amount was sold or not
    function goalReached() public view returns (bool) {
        return tokenCap - teamShare - tokenRemaining >= goal;
    }

    /// @dev Extend parent behavior requiring beneficiary to be identical to msg.sender
    /// @param _beneficiary Token purchaser
    /// @param _weiAmount Amount of wei contributed
    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
        require(_beneficiary == msg.sender, "Message sender and beneficiary address must be the same.");

        super._preValidatePurchase(_beneficiary, _weiAmount);
    }

    /// @dev Extend parent behavior by minting a tokens for the benefit of beneficiary.
    /// @param _beneficiary Token recipient
    /// @param _tokenAmount Token amount
    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(tokenRemaining >= _tokenAmount, "Amount of tokens to deliver exceeds remaining amount.");

        tokenRemaining -= _tokenAmount;

        SicosToken(token).mint(_beneficiary, _tokenAmount);
    }

    /// @dev Extend parent behavior to finish the token minting.
    function finalization() internal {
        require(teamAccount != address(0x0), "Team account has to be set prior to finalization.");

        super.finalization();

        if (goalReached()) {
            SicosToken(token).mint(teamAccount, teamShare);
            SicosToken(token).finishMinting();
        }
        else {
            SicosToken(token).destruct();
        }
    }

}
