pragma solidity 0.4.19;

import "./MintableToken.sol";
import "./KeyRecoverable.sol";
import "./Whitelisted.sol";


/// @title SicosToken
/// @author Autogenerated from a Dia UML diagram
contract SicosToken2 is MintableToken, KeyRecoverable {

    // Attempt to tackle the approve/transferFrom issue in ERC20:
    // If the approver behaves as recommended, i.e. set allowance to zero
    // prior to updating it to a new value, then the new allowance will
    // behave as expected: the spender may transfer the allowed amount of
    // tokens from the approver's account.
    // If the approver just updates the allowance without setting it to
    // zero first, the new allowance will be decreased by the amount of
    // tokens which were already spent from the old allowance.
    // Note: It is not really clear if this behavior violates ERC20,
    //       since the recommendation "set zero first" can be seen as
    //       part of ERC20, and there's no description of how a compliant
    //       token should behave if this recommendation isn't followed by
    //       the approver.
    struct Allowance {
        uint initial;
        uint residual;
    }

    mapping(address => mapping(address => Allowance)) internal allowances;

    /// @dev Constructor
    /// @param _whitelist An Ethereum address
    /// @param _keyRecoverer An Ethereum address
    function SicosToken2(address _whitelist, address _profitDepositor, address _keyRecoverer)
        public
        Whitelisted(_whitelist)
        ProfitSharing(_profitDepositor)
        KeyRecoverable(_keyRecoverer)
    {}

    /// @dev Recover key
    /// @param _oldAddress An Ethereum address
    /// @param _newAddress An Ethereum address
    function recoverKey(address _oldAddress, address _newAddress)
        public
        onlyKeyRecoverer
        onlyWhitelisted(_oldAddress)
        onlyWhitelisted(_newAddress)
    {
        // Ensure that new address is *not* an existing account.
        // Check for account.profitShare is not needed because of following implication:
        //   (account.lastTotalProfits == 0) ==> (account.profitShare == 0)
        require(accounts[_newAddress].balance == 0 && accounts[_newAddress].lastTotalProfits == 0);

        updateProfitShare(_oldAddress);

        accounts[_newAddress] = accounts[_oldAddress];
        delete accounts[_oldAddress];

        KeyRecovered(_oldAddress, _newAddress);
    }

    /// @dev Total supply
    /// @return A positive number
    function totalSupply() public view returns (uint) {
        return totalSupply_;
    }

    /// @dev Balance of
    /// @param _investor An Ethereum address
    /// @return A positive number
    function balanceOf(address _investor) public view returns (uint) {
        return accounts[_investor].balance;
    }

    /// @dev Allowance
    /// @param _investor An Ethereum address
    /// @param _spender An Ethereum address
    /// @return A positive number
    function allowance(address _investor, address _spender) public view returns (uint) {
        return allowances[_investor][_spender].residual;
    }

    /// @dev Approve
    /// @param _spender An Ethereum address
    /// @param _value A positive number
    /// @return True or false
    function approve(address _spender, uint _value)
        public
        onlyWhitelisted(msg.sender)
        notMinting
        returns (bool)
    {
        require(_spender != address(0));

        Allowance storage _allowance = allowances[msg.sender][_spender];
        // This test may be unnecessary as .intial >= .residual should be an invariant.
        uint spent = _allowance.initial > _allowance.residual
                   ? _allowance.initial - _allowance.residual
                   : 0;

        _allowance.initial = _value;
        _allowance.residual = spent < _value ? _value - spent : 0;

        // Log the *effective* new allowance.
        Approval(msg.sender, _spender, _allowance.residual);

        return true;
    }

    /// @dev Transfer
    /// @param _to An Ethereum address
    /// @param _value A positive number
    /// @return True or false
    function transfer(address _to, uint _value) public returns (bool) {
        return _transfer(msg.sender, _to, _value);
    }

    /// @dev Transfer from
    /// @param _from An Ethereum address
    /// @param _to An Ethereum address
    /// @param _value A positive number
    /// @return True or false
    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        uint residual = allowance(_from, msg.sender);

        require(_value <= residual);

        allowances[_from][msg.sender].residual = residual.sub(_value);

        return _transfer(_from, _to, _value);
    }

    /// @dev Transfer
    /// @param _from An Ethereum address
    /// @param _to An Ethereum address
    /// @param _value A positive number
    /// @return True or false
    function _transfer(address _from, address _to, uint _value)
        internal
        onlyWhitelisted(_from)
        onlyWhitelisted(_to)
        notMinting
        returns (bool)
    {
        require(_to != address(0));
        require(_value <= accounts[_from].balance);

        updateProfitShare(_from);
        updateProfitShare(_to);

        accounts[_from].balance = accounts[_from].balance.sub(_value);
        accounts[_to].balance = accounts[_to].balance.add(_value);

        Transfer(_from, _to, _value);

        return true;
    }

}
