pragma solidity 0.4.24;

import "../node_modules/zeppelin-solidity/contracts/crowdsale/distribution/FinalizableCrowdsale.sol";
import "./StokrToken.sol";


/// @title StokrCrowdsale
/// @author Autogenerated from a Dia UML diagram
contract StokrCrowdsale is FinalizableCrowdsale {

    uint public tokenCap;
    uint public tokenGoal;
    uint public tokenRemaining;

    address public teamAccount;
    uint public teamShare;

    mapping(address => uint) investments;


    /// @dev Log entry on token distribution
    /// @param beneficiary An Ethereum address
    /// @param amount A positive number
    event TokenDistribution(
        address indexed beneficiary,
        uint amount
    );

    /// @dev Log entry on rate changed
    /// @param oldRate A positive number
    /// @param newRate A positive number
    event RateChanged(
        uint oldRate,
        uint newRate
    );

    event InvestorRefund(
        address indexed investor,
        uint value
    );


    /// @dev Constructor
    /// @param _token Address of token contract
    /// @param _tokenCap Maximum amount of token (sale + share)
    /// @param _tokenGoal Minimum amount of sold tokens for a successful sale
    /// @param _openingTime Unix timestamp of crowdsale opening
    /// @param _closingTime Unix timestamp of crowdsale closing
    /// @param _rate Tokens per ether rate
    /// @param _wallet Multisig wallet for receiving invested ether
    constructor(StokrToken _token,
                uint _tokenCap,
                uint _tokenGoal,
                uint _openingTime,
                uint _closingTime,
                uint _rate,
                uint _teamShare,
                address _wallet)
        public
        TimedCrowdsale(_openingTime, _closingTime)
        Crowdsale(_rate, _wallet, _token)
    {
        require(_teamShare <= _tokenCap, "Team share must not exceed token cap.");
        require(_tokenGoal > 0, "Goal must be greater than zero.");
        require(_tokenGoal <= _tokenCap - _teamShare, "Goal must be attainable.");

        tokenCap = _tokenCap;
        tokenGoal = _tokenGoal;
        teamShare = _teamShare;
        tokenRemaining = _tokenCap - _teamShare;
    }

    /// @dev Prerequisite to refunding
    modifier onlyWhenRefundPossible() {
        require(isFinalized, "Sale must have been finalized.");
        require(!goalReached(), "No refunds due to reached goal.");
        _;
    }

    /// @dev Distribute tokens.
    /// @param _accounts List of Ethereum addresses who will receive tokens
    /// @param _amounts List of token amounts per account
    function distributeTokens(address[] _accounts, uint[] _amounts) public onlyOwner {
        require(_accounts.length == _amounts.length, "Number of accounts and amounts must be equal.");

        for (uint i = 0; i < _accounts.length; ++i) {
            _deliverTokens(_accounts[i], _amounts[i]);

            emit TokenDistribution(_accounts[i], _amounts[i]);
        }
    }

    /// @dev Set rate
    /// @param _newRate A positive number
    function setRate(uint _newRate) public onlyOwner {
        // A rate change by an order of magnitude (or more) is likely a typo instead of intention
        // Note, this implicitly ensures the new rate cannot be set to zero
        require(rate / 10 < _newRate && _newRate < 10 * rate, "Rate change must be less than an order of magnitude.");

        if (_newRate != rate) {
            emit RateChanged(rate, _newRate);
        }
        rate = _newRate;
    }

    /// @dev Set team account
    /// @param _teamAccount An Ethereum address
    function setTeamAccount(address _teamAccount) public onlyOwner {
        require(_teamAccount != address(0x0), "Team account address must not be zero.");

        teamAccount = _teamAccount;
    }

    /// @dev Time remaining of open crowdsale
    /// @return Duration in seconds, or 0 if crowdsale has ended
    function timeRemaining() public view returns (uint) {
        if (now >= closingTime) {
            return 0;
        }

        return closingTime - now;
    }

    /// @dev Amount of tokens remaining until goal
    function tokenGoalRemaining() public view returns (uint) {
        uint tokenSold = tokenCap - teamShare - tokenRemaining;

        if (tokenSold >= tokenGoal) {
            return 0;
        }

        return tokenGoal - tokenSold;
    }

    /// @dev Check for if soft cap was reached
    /// @return Whether the desired token amount was sold or not
    function goalReached() public view returns (bool) {
        return tokenGoalRemaining() == 0;
    }

    /// @dev Investors can claim refunds here if crowdsale was unsuccessful
    function distributeRefunds(address[] _investors) public onlyOwner onlyWhenRefundPossible {
        for (uint i = 0; i < _investors.length; ++i) {
            _refundInvestor(_investors[i]);
        }
    }

    /// @dev Investors can claim refunds here if crowdsale was unsuccessful
    function claimRefund() public onlyWhenRefundPossible {
        _refundInvestor(msg.sender);
    }

    /// @dev Extend parent behavior requiring beneficiary to be identical to msg.sender
    /// @param _beneficiary Token purchaser
    /// @param _weiAmount Amount of wei contributed
    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
        require(_beneficiary == msg.sender, "Message sender and beneficiary address must be the same.");

        super._preValidatePurchase(_beneficiary, _weiAmount);
    }

    /// @dev Extend parent behavior by minting a tokens for the benefit of beneficiary.
    /// @param _beneficiary Token recipient
    /// @param _tokenAmount Token amount
    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(tokenRemaining >= _tokenAmount, "Amount of tokens to deliver exceeds remaining amount.");

        tokenRemaining -= _tokenAmount;

        StokrToken(token).mint(_beneficiary, _tokenAmount);
    }

    /// @dev Determines how ETH is stored/forwarded on purchases
    function _forwardFunds() internal {
        if (!goalReached()) {
            investments[msg.sender] = investments[msg.sender].add(msg.value);
        }
        else {
            super._forwardFunds();
        }
    }

    /// @dev Transfer invested Ether back to investor
    /// @param _investor Ethereum address of investor
    function _refundInvestor(address _investor) internal {
        uint investment = investments[_investor];

        require(investment > 0);

        delete investments[_investor];

        _investor.transfer(investment);

        emit InvestorRefund(_investor, investment);
    }

    /// @dev Extend parent behavior to finish the token minting.
    function finalization() internal {
        super.finalization();

        if (goalReached()) {
            require(teamAccount != address(0x0), "Team account has to be set prior to finalization.");

            StokrToken(token).mint(teamAccount, teamShare);
            StokrToken(token).finishMinting();
        }
        else {
            StokrToken(token).destruct();
        }
    }

}
