pragma solidity 0.4.24;

import "./MintingCrowdsale.sol";
import "../token/StokrToken.sol";


/// @title StokrCrowdsale
/// @author Autogenerated from a Dia UML diagram
contract StokrCrowdsale is MintingCrowdsale {

    // Soft cap in token units
    uint public tokenGoal;

    // As long as the goal is not reached funds of purchases are held back
    // and investments are assigned to investors here to enable a refunding
    // if the goal is missed upon finalization
    mapping(address => uint) investments;


    // Log entry upon investor refund event
    event InvestorRefund(address indexed investor, uint value);


    /// @dev Constructor
    /// @param _token The token
    /// @param _tokenCap Maximum number of token units to create
    /// @param _tokenGoal Minimum number of sold token units to be successful
    /// @param _tokenPrice Price of a token in EUR cent
    /// @param _etherRate Price of an Ether in EUR cent
    /// @param _rateAdmin Ethereum address of ether rate setting authority
    /// @param _openingTime Block (Unix) timestamp of sale opening time
    /// @param _closingTime Block (Unix) timestamp of sale closing time
    /// @param _companyWallet Ethereum account who will receive sent ether
    /// @param _tokenReserve A number
    /// @param _reserveAccount An address
    constructor(
        StokrToken _token,
        uint _tokenCap,
        uint _tokenGoal,
        uint _tokenPrice,
        uint _etherRate,
        address _rateAdmin,
        uint _openingTime,
        uint _closingTime,
        address _companyWallet,
        uint _tokenReserve,
        address _reserveAccount
    )
        public
        MintingCrowdsale(
            _token,
            _tokenCap,
            _tokenPrice,
            _etherRate,
            _rateAdmin,
            _openingTime,
            _closingTime,
            _companyWallet,
            _tokenReserve,
            _reserveAccount
        )
    {
        require(_tokenGoal <= _tokenCap - _tokenReserve, "Token goal must be attainable");

        tokenGoal = _tokenGoal;
    }

    /// @dev Wether the goal of sold tokens was reached or not
    /// @return True if the sale can be considered successful
    function goalReached() public view returns (bool) {
        return tokenCap - tokenReserve - tokenRemaining >= tokenGoal;
    }

    /// @dev Investors can claim refunds here if crowdsale was unsuccessful
    function distributeRefunds(address[] _investors) public onlyOwner {
        for (uint i = 0; i < _investors.length; ++i) {
            refundInvestor(_investors[i]);
        }
    }

    /// @dev Investors can claim refunds here if crowdsale was unsuccessful
    function claimRefund() public {
        refundInvestor(msg.sender);
    }

    /// @dev Refund an investor if the sale was not successful
    /// @param _investor Ethereum address of investor
    function refundInvestor(address _investor) internal {
        require(isFinalized, "Refunding is not possible until sale has been finalized");
        require(!goalReached(), "Refunding is not possible if goal was reached");

        uint investment = investments[_investor];

        if (investment > 0) {
            investments[_investor] = 0;
            _investor.transfer(investment);

            emit InvestorRefund(_investor, investment);
        }
    }

    /// @dev Overwritten. Kill the token if goal was missed
    function finalize() public onlyOwner {
        super.finalize();

        if (!goalReached()) {
            StokrToken(token).destruct();
        }
    }

    /// @dev Overwritten. Funds are held back until goal was reached
    function forwardFunds() internal {
        if (goalReached()) {
            super.forwardFunds();
        }
        else {
            investments[msg.sender] = investments[msg.sender].add(msg.value);
        }
    }

}
