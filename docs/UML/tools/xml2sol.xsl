<?xml version="1.0" encoding="UTF-8"?>

<!--+
    | Dia-UML to Solidity conversion postprocessor
    | G. Baecker, Tecneos UG, 2018
    +-->
<xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="1.0">
  <xsl:output method="text"/>
  
  <xsl:param name="directory"/>
  <xsl:param name="version">
    <xsl:text>^0.4.0</xsl:text>
  </xsl:param>
  
  <xsl:variable name="indent1">
    <xsl:text>    </xsl:text>
  </xsl:variable>  
  <xsl:variable name="indent2">
    <xsl:value-of select="$indent1"/>
    <xsl:value-of select="$indent1"/>
  </xsl:variable>
  
  <xsl:template match="/">
    <xsl:choose>
      <xsl:when test="string-length($directory)&gt;0">
        <xsl:apply-templates
          mode="files"
          select="diagram/class[
            not(package) and
            (not(stereotype) or 
             stereotype='interface' or 
             stereotype='library')]"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>pragma solidity </xsl:text>
        <xsl:value-of select="$version"/>
        <xsl:text>;&#xa;&#xa;</xsl:text>
        <xsl:apply-templates
          select="diagram/class[
            not(package) and
            (not(stereotype) or 
             stereotype='interface' or 
             stereotype='library')]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template mode="files" match="class">
    <xsl:variable name="name" select="name"/>
    <xsl:variable name="dependency-unary-count">
      <xsl:choose>
        <xsl:when test="//generalization[from=current()/@id]">
          <xsl:text>*</xsl:text>
        </xsl:when>
        <xsl:when test="//realization[from=current()/@id]">
          <xsl:text>*</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:for-each select="//association[to=current()/@id]">
            <xsl:variable name="id" select="from"/>
            <xsl:if test="//class[@id=$id and 
                                  (not(stereotype) or 
                                   stereotype='interface' or 
                                   stereotype='library')]">
              <xsl:text>*</xsl:text>
            </xsl:if>
          </xsl:for-each>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:document href="{$directory}/{$name}.sol" method="text">
      <xsl:text>pragma solidity </xsl:text>
      <xsl:value-of select="$version"/>
      <xsl:text>;&#xa;</xsl:text>
      <!-- imports -->
      <xsl:if test="string-length($dependency-unary-count)&gt;0">
        <xsl:text>&#xa;</xsl:text>
        <!-- due to inheritance -->
        <xsl:for-each select="
            //generalization[from=current()/@id]|
            //realization[from=current()/@id]">
          <xsl:variable name="id" select="to"/>
          <xsl:variable name="node" select="//class[@id=$id]"/>
          <xsl:text>import &quot;</xsl:text>
          <xsl:if test="not($node/package)">
            <xsl:text>./</xsl:text>
          </xsl:if>
          <xsl:value-of select="$node/name"/>
          <xsl:text>.sol&quot;;&#xa;</xsl:text>
        </xsl:for-each>
        <!-- due to usage -->
        <xsl:for-each select="//association[to=current()/@id]">
          <xsl:variable name="id" select="from"/>
          <xsl:variable name="node" select="//class[@id=$id]"/>
          <xsl:if test="not($node/stereotype) or 
                        $node/stereotype='interface' or 
                        $node/stereotype='library'">
            <xsl:text>import &quot;</xsl:text>
            <xsl:if test="not($node/package)">
              <xsl:text>./</xsl:text>
            </xsl:if>
            <xsl:value-of select="$node/name"/>
            <xsl:text>.sol&quot;;&#xa;</xsl:text>
          </xsl:if>
        </xsl:for-each>
      </xsl:if>
      <xsl:text>&#xa;</xsl:text>
      <xsl:apply-templates select="."/>
    </xsl:document>
  </xsl:template>
  
  <xsl:template match="class">
    <xsl:text>&#xa;</xsl:text>
    <!-- comments -->
    <xsl:text>/// @title </xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>&#xa;/// @author Autogenerated from a Dia UML diagram&#xa;</xsl:text>
    <xsl:if test="comment">
      <xsl:text>/// @dev </xsl:text>
      <xsl:value-of select="comment"/>
      <xsl:text>&#xa;</xsl:text>
    </xsl:if>
    <!-- interface/contract name -->
    <xsl:choose>
      <xsl:when test="
          abstract and 
          not(attribute) and 
          count(operator/abstract)=count(operator) and
          not(//generalization[from=current()/@id]) and
          not(//realization[from=current()/@id]) and
          not(//association[to=current()/@id])">
        <xsl:text>interface </xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>contract </xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:value-of select="name"/>
    <!-- inheritance -->
    <xsl:for-each select="
        //generalization[from=current()/@id]|
        //realization[from=current()/@id]">
      <xsl:variable name="id" select="to"/>
      <xsl:choose>
        <xsl:when test="position()=1">
          <xsl:text> is </xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>, </xsl:text>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:value-of select="//class[@id=$id]/name"/>
    </xsl:for-each>
    <xsl:text> {&#xa;</xsl:text>
    <!-- typedefs -->
    <xsl:for-each select="//association[to=current()/@id]">
      <xsl:variable name="id" select="from"/>
      <xsl:variable name="node" select="//class[@id=$id]"/>
      <xsl:if test="$node/stereotype='struct' or $node/stereotype='enum'">
        <xsl:apply-templates select="$node"/>
      </xsl:if>
    </xsl:for-each>
    <!-- variables -->
    <xsl:if test="attribute">
      <xsl:text>&#xa;</xsl:text>
      <xsl:apply-templates select="attribute"/>
    </xsl:if>
    <!-- events -->
    <xsl:apply-templates select="operation[stereotype='event']"/>
    <!-- modifiers -->
    <xsl:apply-templates select="operation[stereotype='modifier']"/>
    <!-- functions -->
    <xsl:apply-templates select="operation[not(stereotype)]"/>
    <xsl:text>&#xa;}&#xa;&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="class[stereotype='struct']">
    <!-- comments -->
    <xsl:for-each select="comment">
      <xsl:value-of select="$indent1"/>
      <xsl:text>/// @dev </xsl:text>
      <xsl:value-of select="."/>
      <xsl:text>&#xa;</xsl:text>
    </xsl:for-each>
    <!-- struct name -->
    <xsl:text>&#xa;</xsl:text>
    <xsl:value-of select="$indent1"/>
    <xsl:text>struct </xsl:text>
    <xsl:value-of select="name"/>
    <!-- attributes -->
    <xsl:text> {&#xa;</xsl:text>
    <xsl:apply-templates select="attribute"/>
    <xsl:value-of select="$indent1"/>
    <xsl:text>}&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="class[stereotype='enum']">
    <!-- comments -->
    <xsl:for-each select="comment">
      <xsl:value-of select="$indent1"/>
      <xsl:text>/// @dev </xsl:text>
      <xsl:value-of select="."/>
      <xsl:text>&#xa;</xsl:text>
    </xsl:for-each>
    <xsl:if test="comment">
      <xsl:value-of select="$indent1"/>
      <xsl:text>/// @dev </xsl:text>
      <xsl:value-of select="comment"/>
      <xsl:text>&#xa;</xsl:text>
    </xsl:if>
    <!-- enum name -->
    <xsl:text>&#xa;</xsl:text>
    <xsl:value-of select="$indent1"/>
    <xsl:text>enum </xsl:text>
    <xsl:value-of select="name"/>
    <!-- attributes -->
    <xsl:text> {&#xa;</xsl:text>
    <xsl:apply-templates select="attribute"/>
    <xsl:value-of select="$indent1"/>
    <xsl:text>}&#xa;</xsl:text>
  </xsl:template>
    
  <xsl:template match="attribute">
    <!-- type -->
    <xsl:value-of select="$indent1"/>
    <xsl:call-template name="type">
      <xsl:with-param name="name" select="type"/>
    </xsl:call-template>
    <!-- visibility -->
    <xsl:choose>
      <xsl:when test="visibility='public'">
        <xsl:text> public</xsl:text>
      </xsl:when>
      <xsl:when test="visibility='private'">
        <xsl:text> private</xsl:text>
      </xsl:when>
      <xsl:when test="visibility='protected'">
        <xsl:text> internal</xsl:text>
      </xsl:when>
    </xsl:choose>
    <!-- name -->
    <xsl:text> </xsl:text>
    <xsl:value-of select="name"/>
    <!-- value -->
    <xsl:if test="value">
      <xsl:text> = </xsl:text>
      <xsl:value-of select="value"/>
    </xsl:if>
    <xsl:text>;</xsl:text>
    <!-- comment -->
    <xsl:if test="comment">
      <xsl:text> //</xsl:text>
      <xsl:for-each select="comment">
        <xsl:text> </xsl:text>
        <xsl:value-of select="."/>
      </xsl:for-each>
    </xsl:if>
    <xsl:text>&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="class[stereotype='struct']/attribute">
    <xsl:value-of select="$indent2"/>
    <xsl:call-template name="type">
      <xsl:with-param name="name" select="type"/>
    </xsl:call-template>
    <xsl:text> </xsl:text>
    <xsl:value-of select="name"/>
    <xsl:text>;</xsl:text>
    <xsl:if test="comment">
      <xsl:text> //</xsl:text>
      <xsl:for-each select="comment">
        <xsl:text> </xsl:text>
        <xsl:value-of select="."/>
      </xsl:for-each>
    </xsl:if>
    <xsl:text>&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="class[stereotype='enum']/attribute">
    <xsl:value-of select="$indent2"/>
    <xsl:value-of select="name"/>
    <xsl:if test="position()!=last()">
      <xsl:text>,</xsl:text>
    </xsl:if>
    <xsl:if test="comment">
      <xsl:text> //</xsl:text>
      <xsl:for-each select="comment">
        <xsl:text> </xsl:text>
        <xsl:value-of select="."/>
      </xsl:for-each>
    </xsl:if>
    <xsl:text>&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="operation[stereotype='event']">
    <xsl:text>&#xa;</xsl:text>
    <!-- comments -->
    <xsl:call-template name="comment"/>
    <!-- event name -->
    <xsl:value-of select="$indent1"/>
    <xsl:text>event </xsl:text>
    <xsl:value-of select="name"/>
    <!-- parameters -->
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="parameter"/>
    <xsl:text>);&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="operation[stereotype='modifier']">
    <xsl:text>&#xa;</xsl:text>
    <!-- comments -->
    <xsl:call-template name="comment"/>
    <!-- modifier name -->
    <xsl:value-of select="$indent1"/>
    <xsl:text>modifier </xsl:text>
    <xsl:value-of select="name"/>
    <!-- parameters -->
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="parameter"/>
    <xsl:text>) {&#xa;</xsl:text>
    <xsl:value-of select="$indent2"/>
    <xsl:text>require(IMPLEMENTATION);&#xa;</xsl:text>
    <xsl:value-of select="$indent2"/>
    <xsl:text>_;&#xa;</xsl:text>
    <xsl:value-of select="$indent1"/>
    <xsl:text>}&#xa;</xsl:text>
  </xsl:template>
  
  <xsl:template match="operation">
    <xsl:text>&#xa;</xsl:text>
    <!-- comments -->
    <xsl:call-template name="comment"/>
    <!-- function name -->
    <xsl:value-of select="$indent1"/>
    <xsl:if test="name!='constructor'">
      <xsl:text>function </xsl:text>
    </xsl:if>
    <xsl:value-of select="name"/>
    <!-- parameters -->
    <xsl:text>(</xsl:text>
    <xsl:apply-templates select="parameter"/>
    <xsl:text>)</xsl:text>
    <xsl:choose>
      <xsl:when test="visibility='public' and 
                      ../stereotype='interface'">
        <xsl:text> external</xsl:text>
      </xsl:when>
      <xsl:when test="visibility='public'">
        <xsl:text> public</xsl:text>
      </xsl:when>
      <xsl:when test="visibility='private'">
        <xsl:text> private</xsl:text>
      </xsl:when>
      <xsl:when test="visibility='protected'">
        <xsl:text> internal</xsl:text>
      </xsl:when>
    </xsl:choose>
    <!-- view -->
    <xsl:if test="const">
      <xsl:text> view</xsl:text>
    </xsl:if>
    <!-- modifiers -->
    <xsl:for-each select="comment">
      <xsl:variable name="name">
        <xsl:choose>
          <xsl:when test="contains(text(),'(')">
            <xsl:value-of select="substring-before(text(),'(')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="text()"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:if test="
          $name='payable' or 
          //class/operation[name=$name and stereotype='modifier'] or
          //class[name=$name]">
        <xsl:text> </xsl:text>
        <xsl:value-of select="text()"/>
      </xsl:if>
    </xsl:for-each>
    <!-- returns -->
    <xsl:if test="type">
      <xsl:text> returns (</xsl:text>
      <xsl:call-template name="type">
        <xsl:with-param name="name" select="type"/>
      </xsl:call-template>
      <xsl:text>)</xsl:text>
    </xsl:if>
    <!-- body -->
    <xsl:choose>
      <xsl:when test="abstract">
        <xsl:text>;&#xa;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text> {&#xa;</xsl:text>
        <xsl:value-of select="$indent2"/>
        <xsl:text>require(IMPLEMENTATION);&#xa;</xsl:text>
        <xsl:value-of select="$indent1"/>
        <xsl:text>}&#xa;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template match="parameter">
    <xsl:if test="position()!=1">
      <xsl:text>, </xsl:text>
    </xsl:if>
    <xsl:call-template name="type">
      <xsl:with-param name="name" select="type"/>
    </xsl:call-template>
    <xsl:if test="string-length(name)&gt;0">
      <xsl:text> </xsl:text>
      <xsl:value-of select="name"/>
    </xsl:if>
  </xsl:template>
  
  <xsl:template match="node()|@*"/>
  
  <xsl:template name="type">
    <xsl:param name="name"/>
    <xsl:choose>
      <xsl:when test="
          substring($name,1,1)='{' and 
          contains($name,'→') and 
          substring($name,string-length($name))='}'">
        <xsl:text>mapping(</xsl:text>
        <xsl:value-of select="substring(substring-before($name,'→'),2)"/>
        <xsl:text> =&gt; </xsl:text>
        <xsl:call-template name="type">
          <xsl:with-param 
              name="name" 
              select="substring-after(substring($name,1,string-length($name)-1),'→')"/>
        </xsl:call-template>
        <xsl:text>)</xsl:text>
      </xsl:when>
      <xsl:when test="
          contains($name,'[') and 
          substring($name,string-length($name))=']'">
        <xsl:variable name="suffix" select="concat('[',substring-after($name,'['))"/>
        <xsl:value-of select="substring-before($name,'[')"/>
        <xsl:choose>
          <xsl:when test="translate($suffix,'0123456789','')='[]'">
            <xsl:value-of select="$suffix"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>[]</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$name"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template name="comment">
    <!-- count comment lines that aren't modifiers or base constructors -->
    <xsl:variable name="line-unary-count">
      <xsl:for-each select="comment">
        <xsl:variable name="name">
          <xsl:choose>
            <xsl:when test="contains(text(),'(')">
              <xsl:value-of select="substring-before(text(),'(')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="text()"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:if test="not(
            $name='payable' or 
            //class/operation[name=$name and stereotype='modifier' or
            //class/name=$name])">
          <xsl:text>*</xsl:text>
        </xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <!-- descriptions -->
    <xsl:choose>
      <!-- there are non-modifier comment lines -->
      <xsl:when test="string-length($line-unary-count)&gt;0">
        <xsl:for-each select="comment">
          <xsl:variable name="name">
            <xsl:choose>
              <xsl:when test="contains(text(),'(')">
                <xsl:value-of select="substring-before(text(),'(')"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="text()"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:if test="not(
              $name='payable' or
              //class/operation[name=$name and stereotype='modifier'])">
            <xsl:value-of select="$indent1"/>
            <xsl:text>/// @dev </xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>&#xa;</xsl:text>
          </xsl:if>
        </xsl:for-each>
      </xsl:when>
      <!-- the function name is the same as contract name -->
      <xsl:when test="name=../name or name='constructor'">
        <xsl:value-of select="$indent1"/>
        <xsl:text>/// @dev Constructor&#xa;</xsl:text>
      </xsl:when>
      <!-- the function name is empty -->
      <xsl:when test="not(name)">
        <xsl:value-of select="$indent1"/>
        <xsl:text>/// @dev Default function&#xa;</xsl:text>
      </xsl:when>
      <!-- this is an event -->
      <xsl:when test="stereotype='event'">
        <xsl:value-of select="$indent1"/>
        <xsl:text>/// @dev Log entry on </xsl:text>
        <xsl:call-template name="comment-name">
          <xsl:with-param
            name="name" 
            select="normalize-space(translate(name,'_',' '))"/>
        </xsl:call-template>
        <xsl:text>&#xa;</xsl:text>
      </xsl:when>
      <!-- this is an modifier -->
      <xsl:when test="stereotype='modifier'">
        <xsl:value-of select="$indent1"/>
        <xsl:text>/// @dev Ensure </xsl:text>
        <xsl:call-template name="comment-name">
          <xsl:with-param
            name="name"
            select="normalize-space(translate(name,'_',' '))"/>
        </xsl:call-template>
        <xsl:text>&#xa;</xsl:text>
      </xsl:when>
      <!-- this is a function -->
      <xsl:otherwise>
        <xsl:value-of select="$indent1"/>
        <xsl:text>/// @dev </xsl:text>
        <xsl:call-template name="capitalize">
          <xsl:with-param name="text">
            <xsl:call-template name="comment-name"> 
              <xsl:with-param
                name="name" 
                select="normalize-space(translate(name,'_',' '))"/>
            </xsl:call-template>
          </xsl:with-param>
        </xsl:call-template>
        <xsl:text>&#xa;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    <!-- parameters -->
    <xsl:for-each select="parameter">
      <xsl:value-of select="$indent1"/>
      <xsl:text>/// @param </xsl:text>
      <xsl:value-of select="name"/>
      <xsl:text> </xsl:text>
      <xsl:choose>
        <xsl:when test="comment">
          <xsl:value-of select="comment"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="capitalize">
            <xsl:with-param name="text">
              <xsl:call-template name="comment-type"> 
                <xsl:with-param name="name" select="type"/>
              </xsl:call-template>
            </xsl:with-param>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>&#xa;</xsl:text>
    </xsl:for-each>
    <!-- returns -->
    <xsl:if test="type">
      <xsl:value-of select="$indent1"/>
      <xsl:text>/// @return </xsl:text>
      <xsl:call-template name="capitalize">
        <xsl:with-param name="text">
          <xsl:call-template name="comment-type"> 
            <xsl:with-param name="name" select="type"/>
          </xsl:call-template>
        </xsl:with-param>
      </xsl:call-template>
      <xsl:text>&#xa;</xsl:text>
    </xsl:if>
  </xsl:template>
  
  <xsl:template name="comment-name">
    <xsl:param name="name"/>
    <xsl:if test="string-length($name)&gt;0">
      <xsl:variable name="length" select="
        string-length(substring-before(concat('#',translate(
          substring($name,2),
          '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
          '************************************')),'*'))"/>
      <xsl:variable name="lowered" select="
        translate($name,
          'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
          'abcdefghijklmnopqrstuvwxyz')"/>
      <xsl:choose>
        <xsl:when test="$length=0">
          <xsl:value-of select="$lowered"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="substring($lowered,1,$length)"/>
          <xsl:if test="
              not(contains('0123456789',substring($name,$length,1))) or
              not(contains('0123456789',substring($name,$length+1,1)))">
            <xsl:text> </xsl:text>
          </xsl:if>
          <xsl:call-template name="comment-name">
            <xsl:with-param name="name" select="substring($name,$length+1)"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>
  
  <xsl:template name="comment-type">
    <xsl:param name="name"/>
    <xsl:choose>
      <xsl:when test="
          substring($name,1,1)='{' and 
          contains($name,'→') and 
          substring($name,string-length($name))='}'">
        <xsl:text>mapping where the key is </xsl:text>
        <xsl:value-of select="substring(substring-before($name,'→'),2)"/>
        <xsl:text> and the value is </xsl:text>
        <xsl:call-template name="type">
          <xsl:with-param 
              name="name" 
              select="substring-after(substring($name,1,string-length($name)-1),'→')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="
          contains($name,'[') and 
          substring($name,string-length($name))=']'">
        <xsl:variable name="suffix" select="concat('[',substring-after($name,'['))"/>
        <xsl:text>a list</xsl:text>
        <xsl:if test="$suffix!='[]' and translate($suffix,'0123456789','')='[]'">
          <xsl:text> of length </xsl:text>
          <xsl:value-of select="substring($suffix,2,string-length($suffix)-2)"/>
        </xsl:if>
        <xsl:text> where each entry is </xsl:text>
        <xsl:call-template name="comment-type">
          <xsl:with-param name="name" select="substring-before($name,'[')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:when test="$name='bool'">
        <xsl:text>true or false</xsl:text>
      </xsl:when>
      <xsl:when test="starts-with($name,'int')">
        <xsl:text>a positive or negative number</xsl:text>
      </xsl:when>
      <xsl:when test="starts-with($name,'uint')">
        <xsl:text>a positive number</xsl:text>
      </xsl:when>
      <xsl:when test="starts-with($name,'fixed')">
        <xsl:text>a positive or negative fixed point number</xsl:text>
      </xsl:when>
      <xsl:when test="starts-with($name,'ufixed')">
        <xsl:text>a positive fixed point number</xsl:text>
      </xsl:when>
      <xsl:when test="$name='address'">
        <xsl:text>an Ethereum address</xsl:text>
      </xsl:when>
      <xsl:when test="$name='string'">
        <xsl:text>a text string</xsl:text>
      </xsl:when>
      <xsl:when test="$name='bytes'">
        <xsl:text>an array of bytes</xsl:text>
      </xsl:when>
      <xsl:when test="starts-with($name,'bytes')">
        <xsl:text>an string of </xsl:text>
        <xsl:value-of select="substring($name,6)"/>
        <xsl:text> bytes</xsl:text>
      </xsl:when>
      <xsl:when test="contains('AEIOUaeiou',substring($name,1,1))">
        <xsl:text>an </xsl:text>
        <xsl:value-of select="$name"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>a </xsl:text>
        <xsl:value-of select="$name"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
  
  <xsl:template name="capitalize">
    <xsl:param name="text"/>
    <xsl:value-of select="
      translate(substring($text,1,1),
        'abcdefghijklmnopqrstuvwxyz',
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
    <xsl:value-of select="substring($text,2)"/>
  </xsl:template>
  
</xsl:stylesheet>
