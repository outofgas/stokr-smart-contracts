%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english,openany]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}
\sphinxsetup{verbatimwithframe=true,VerbatimBorderColor={rgb}{0.9,0.9,0.9}}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\usepackage{helvet}
\usepackage{inconsolata}
\renewcommand{\familydefault}{\sfdefault}


\title{TokenPlatform Documentation}
\date{Jul 03, 2018}
\release{}
\author{Sicos}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Whitelist}
\label{\detokenize{_contracts/Whitelist:tokenplatform-s-solidity-sources}}\label{\detokenize{_contracts/Whitelist:whitelist}}\label{\detokenize{_contracts/Whitelist::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/ownership/Ownable.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title Whitelist}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{Whitelist} \PYG{k+kr}{is} \PYG{n+nx}{Ownable} \PYG{p}{\PYGZob{}}

    \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{k+kt}{bool}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{admins}\PYG{p}{;}
    \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{k+kt}{bool}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{isWhitelisted}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on admin added}
    \PYG{c+c1}{/// @param admin An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{AdminAdded}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{admin}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on admin removed}
    \PYG{c+c1}{/// @param admin An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{AdminRemoved}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{admin}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on investor added}
    \PYG{c+c1}{/// @param admin An Ethereum address}
    \PYG{c+c1}{/// @param investor An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{InvestorAdded}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{admin}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{investor}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on investor removed}
    \PYG{c+c1}{/// @param admin An Ethereum address}
    \PYG{c+c1}{/// @param investor An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{InvestorRemoved}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{admin}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{investor}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Only admin}
    \PYG{k+kd}{modifier} \PYG{n+nx}{onlyAdmin}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{admins}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Add admin}
    \PYG{c+c1}{/// @param \PYGZus{}admin An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{addAdmin}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}admin}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n+nx}{admins}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n+nx}{admins}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
            \PYG{k+kr}{emit} \PYG{n+nx}{AdminAdded}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Remove admin}
    \PYG{c+c1}{/// @param \PYGZus{}admin An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{removeAdmin}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}admin}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{admins}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n+nx}{admins}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
            \PYG{k+kr}{emit} \PYG{n+nx}{AdminRemoved}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}admin}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Add to whitelist}
    \PYG{c+c1}{/// @param \PYGZus{}investors A list where each entry is an Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{addToWhitelist}\PYG{p}{(}\PYG{k+kt}{address}\PYG{p}{[}\PYG{p}{]} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyAdmin} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{uint256} \PYG{n+nx}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n+nx}{isWhitelisted}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{isWhitelisted}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
                \PYG{k+kr}{emit} \PYG{n+nx}{InvestorAdded}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Remove from whitelist}
    \PYG{c+c1}{/// @param \PYGZus{}investors A list where each entry is an Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{removeFromWhitelist}\PYG{p}{(}\PYG{k+kt}{address}\PYG{p}{[}\PYG{p}{]} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyAdmin} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{uint256} \PYG{n+nx}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{isWhitelisted}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{isWhitelisted}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{k+kc}{false}\PYG{p}{;}
                \PYG{k+kr}{emit} \PYG{n+nx}{InvestorRemoved}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}investors}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{KeyRecoverer}
\label{\detokenize{_contracts/KeyRecoverer:keyrecoverer}}\label{\detokenize{_contracts/KeyRecoverer::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/ownership/Ownable.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./KeyRecoverable.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title SicosToken}
\PYG{c+c1}{/// @author C+B}
\PYG{k+kd}{contract} \PYG{n+nx}{KeyRecoverer} \PYG{k+kr}{is} \PYG{n+nx}{Ownable} \PYG{p}{\PYGZob{}}

     \PYG{c+c1}{// Indices of tokens within array. Note: There\PYGZsq{}s no valid token at index 0.}
    \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{k+kt}{uint}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{indices}\PYG{p}{;}
     \PYG{c+c1}{// Array of tokens. Note: At index 0 is a placeholder that shouldn\PYGZsq{}t be removed ever.}
    \PYG{k+kt}{address}\PYG{p}{[}\PYG{p}{]} \PYG{k+kr}{public} \PYG{n+nx}{tokens}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Constructor}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{push}\PYG{p}{(}\PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Placeholder at index 0.}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Check if a token is registered here}
    \PYG{c+c1}{/// @param \PYGZus{}token Ethereum address of token contract instance}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{containsToken}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}token}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{indices}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Register a key recoverable token}
    \PYG{c+c1}{/// @param \PYGZus{}token Ethereum address of token contract instance}
    \PYG{k+kd}{function} \PYG{n+nx}{addToken}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}token}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}token} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n+nx}{containsToken}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{indices}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;}
        \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{push}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Unregister a key recoverable token}
    \PYG{c+c1}{/// @param \PYGZus{}token Ethereum address of token contract instance}
    \PYG{k+kd}{function} \PYG{n+nx}{removeToken}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}token}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}token} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{containsToken}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Array index of token to delete.}
        \PYG{k+kt}{uint} \PYG{n+nx}{index} \PYG{o}{=} \PYG{n+nx}{indices}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{]}\PYG{p}{;}

        \PYG{c+c1}{// Remove token from array.}
        \PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{index}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
        \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length} \PYG{o}{=} \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}

        \PYG{c+c1}{// Update token indices.}
        \PYG{n+nx}{indices}\PYG{p}{[}\PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{index}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{index}\PYG{p}{;}
        \PYG{k}{delete} \PYG{n+nx}{indices}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}token}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Recover key for an investor in all tokens that are registered here}
    \PYG{c+c1}{/// @param \PYGZus{}oldAddress Old Ethereum address of the investor}
    \PYG{c+c1}{/// @param \PYGZus{}newAddress New Ethereum address of the investor}
    \PYG{k+kd}{function} \PYG{n+nx}{recoverKey}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{uint} \PYG{n+nx}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{KeyRecoverable}\PYG{p}{(}\PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{keyRecoverer}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{k+kt}{address}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n+nx}{KeyRecoverable}\PYG{p}{(}\PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{recoverKey}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Check if this instance is the keyRecoverer of all registered tokens.}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{checkTokens}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{n+nx}{onlyOwner} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{uint} \PYG{n+nx}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n+nx}{i} \PYG{o}{\PYGZlt{}} \PYG{n+nx}{tokens}\PYG{p}{.}\PYG{n+nx}{length}\PYG{p}{;} \PYG{n+nx}{i}\PYG{o}{++}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{KeyRecoverable}\PYG{p}{(}\PYG{n+nx}{tokens}\PYG{p}{[}\PYG{n+nx}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{keyRecoverer}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{k+kt}{address}\PYG{p}{(}\PYG{k}{this}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{k+kc}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{k+kc}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{SicosCrowdsale}
\label{\detokenize{_contracts/SicosCrowdsale:sicoscrowdsale}}\label{\detokenize{_contracts/SicosCrowdsale::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/crowdsale/validation/CappedCrowdsale.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./MintableToken.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title SicosCrowdsale}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{SicosCrowdsale} \PYG{k+kr}{is} \PYG{n+nx}{RefundableCrowdsale}\PYG{p}{,} \PYG{n+nx}{CappedCrowdsale} \PYG{p}{\PYGZob{}}

    \PYG{k+kt}{address} \PYG{k+kr}{public} \PYG{n+nx}{teamAccount}\PYG{p}{;}
    \PYG{k+kt}{uint} \PYG{k+kr}{public} \PYG{n+nx}{teamShare}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Crowdsale}
    \PYG{c+c1}{/// @param \PYGZus{}token An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}openingTime A positive number}
    \PYG{c+c1}{/// @param \PYGZus{}closingTime A positive number}
    \PYG{c+c1}{/// @param \PYGZus{}goal A positive number}
    \PYG{c+c1}{/// @param \PYGZus{}rate A positive number}
    \PYG{c+c1}{/// @param \PYGZus{}cap A positive number}
    \PYG{c+c1}{/// @param \PYGZus{}wallet An Ethereum address}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{n+nx}{MintableToken} \PYG{n+nx}{\PYGZus{}token}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}openingTime}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}closingTime}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}goal}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}rate}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}cap}\PYG{p}{,}
                \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}teamShare}\PYG{p}{,}
                \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}wallet}\PYG{p}{)}
        \PYG{k+kr}{public}
        \PYG{n+nx}{RefundableCrowdsale}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}goal}\PYG{p}{)}
        \PYG{n+nx}{CappedCrowdsale}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}cap}\PYG{p}{)}
        \PYG{n+nx}{TimedCrowdsale}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}openingTime}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}closingTime}\PYG{p}{)}
        \PYG{n+nx}{Crowdsale}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}rate}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}wallet}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}token}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{teamShare} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}teamShare}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Log entry on rate changed}
    \PYG{c+c1}{/// @param oldRate A positive number}
    \PYG{c+c1}{/// @param newRate A positive number}
    \PYG{k+kd}{event} \PYG{n+nx}{RateChanged}\PYG{p}{(}\PYG{k+kt}{uint} \PYG{n+nx}{oldRate}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{newRate}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Set rate}
    \PYG{c+c1}{/// @param \PYGZus{}newRate A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{setRate}\PYG{p}{(}\PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}newRate}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newRate} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{\PYGZus{}newRate} \PYG{o}{!=} \PYG{n+nx}{rate}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{emit} \PYG{n+nx}{RateChanged}\PYG{p}{(}\PYG{n+nx}{rate}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}newRate}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nx}{rate} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}newRate}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Set team account}
    \PYG{c+c1}{/// @param \PYGZus{}teamAccount An Ethereum address.}
    \PYG{k+kd}{function} \PYG{n+nx}{setTeamAccount}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}teamAccount}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}teamAccount} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{teamAccount} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}teamAccount}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Extend parent behavior requiring beneficiary to be identical to msg.sender}
    \PYG{c+c1}{/// @param \PYGZus{}beneficiary Token purchaser}
    \PYG{c+c1}{/// @param \PYGZus{}weiAmount Amount of wei contributed}
    \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}preValidatePurchase}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}beneficiary}\PYG{p}{,} \PYG{k+kt}{uint256} \PYG{n+nx}{\PYGZus{}weiAmount}\PYG{p}{)} \PYG{k+kr}{internal} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}beneficiary} \PYG{o}{==} \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{super}\PYG{p}{.}\PYG{n+nx}{\PYGZus{}preValidatePurchase}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}beneficiary}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}weiAmount}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Extend parent behavior by minting a tokens for the benefit of beneficiary.}
    \PYG{c+c1}{/// @param \PYGZus{}beneficiary Token recipient}
    \PYG{c+c1}{/// @param \PYGZus{}tokenAmount Token amount}
    \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}deliverTokens}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}beneficiary}\PYG{p}{,} \PYG{k+kt}{uint256} \PYG{n+nx}{\PYGZus{}tokenAmount}\PYG{p}{)} \PYG{k+kr}{internal} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{MintableToken}\PYG{p}{(}\PYG{n+nx}{token}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{mint}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}beneficiary}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}tokenAmount}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Extend parent behavior to finish the token minting.}
    \PYG{k+kd}{function} \PYG{n+nx}{finalization}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{internal} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{teamAccount} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{super}\PYG{p}{.}\PYG{n+nx}{finalization}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{MintableToken}\PYG{p}{(}\PYG{n+nx}{token}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{mint}\PYG{p}{(}\PYG{n+nx}{teamAccount}\PYG{p}{,} \PYG{n+nx}{teamShare}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{MintableToken}\PYG{p}{(}\PYG{n+nx}{token}\PYG{p}{)}\PYG{p}{.}\PYG{n+nx}{finishMinting}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{Whitelisted}
\label{\detokenize{_contracts/Whitelisted:whitelisted}}\label{\detokenize{_contracts/Whitelisted::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/ownership/Ownable.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./Whitelist.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title Whitelisted}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{Whitelisted} \PYG{k+kr}{is} \PYG{n+nx}{Ownable} \PYG{p}{\PYGZob{}}

    \PYG{n+nx}{Whitelist} \PYG{k+kr}{public} \PYG{n+nx}{whitelist}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on whitelist changed}
    \PYG{c+c1}{/// @param newWhitelist An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{WhitelistChanged}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{newWhitelist}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Ensure only whitelisted}
    \PYG{k+kd}{modifier} \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}address}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{whitelist}\PYG{p}{.}\PYG{n+nx}{isWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}address}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Constructor}
    \PYG{c+c1}{/// @param \PYGZus{}whitelist An Ethereum address}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}whitelist}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{setWhitelist}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}whitelist}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Set whitelist}
    \PYG{c+c1}{/// @param \PYGZus{}newWhitelist An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{setWhitelist}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newWhitelist}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newWhitelist} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{whitelist} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{\PYGZus{}newWhitelist} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{n+nx}{whitelist}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{emit} \PYG{n+nx}{WhitelistChanged}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newWhitelist}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nx}{whitelist} \PYG{o}{=} \PYG{n+nx}{Whitelist}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newWhitelist}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{KeyRecoverable}
\label{\detokenize{_contracts/KeyRecoverable:keyrecoverable}}\label{\detokenize{_contracts/KeyRecoverable::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/ownership/Ownable.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title KeyRecoverable}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{KeyRecoverable} \PYG{k+kr}{is} \PYG{n+nx}{Ownable} \PYG{p}{\PYGZob{}}

    \PYG{k+kt}{address} \PYG{k+kr}{public} \PYG{n+nx}{keyRecoverer}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on key recoverer changed}
    \PYG{c+c1}{/// @param newKeyRecoverer An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{KeyRecovererChanged}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{newKeyRecoverer}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on key recovered}
    \PYG{c+c1}{/// @param oldAddress An Ethereum address}
    \PYG{c+c1}{/// @param newAddress An Ethereum address}
    \PYG{k+kd}{event} \PYG{n+nx}{KeyRecovered}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{oldAddress}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{newAddress}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Ensure only key recoverer}
    \PYG{k+kd}{modifier} \PYG{n+nx}{onlyKeyRecoverer}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender} \PYG{o}{==} \PYG{n+nx}{keyRecoverer}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Constructor}
    \PYG{c+c1}{/// @param \PYGZus{}keyRecoverer An Ethereum address}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}keyRecoverer}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{setKeyRecoverer}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}keyRecoverer}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Set key recoverer}
    \PYG{c+c1}{/// @param \PYGZus{}newKeyRecoverer An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{setKeyRecoverer}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newKeyRecoverer}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newKeyRecoverer} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{keyRecoverer} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{\PYGZus{}newKeyRecoverer} \PYG{o}{!=} \PYG{n+nx}{keyRecoverer}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{emit} \PYG{n+nx}{KeyRecovererChanged}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newKeyRecoverer}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nx}{keyRecoverer} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}newKeyRecoverer}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Recover key}
    \PYG{c+c1}{/// @param \PYGZus{}oldAddress An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}newAddress An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{recoverKey}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)} \PYG{k+kr}{public}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{ProfitSharing}
\label{\detokenize{_contracts/ProfitSharing:profitsharing}}\label{\detokenize{_contracts/ProfitSharing::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/ownership/Ownable.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/token/ERC20/ERC20.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}../zeppelin\PYGZhy{}solidity/contracts/math/SafeMath.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title ProfitSharing}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{ProfitSharing} \PYG{k+kr}{is} \PYG{n+nx}{Ownable} \PYG{p}{\PYGZob{}}

    \PYG{k+kr}{using} \PYG{n+nx}{SafeMath} \PYG{k}{for} \PYG{k+kt}{uint}\PYG{p}{;}

    \PYG{k+kd}{struct} \PYG{n+nx}{InvestorAccount} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{uint} \PYG{n+nx}{balance}\PYG{p}{;}
        \PYG{k+kt}{uint} \PYG{n+nx}{lastTotalProfits}\PYG{p}{;}
        \PYG{k+kt}{uint} \PYG{n+nx}{profitShare}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{n+nx}{InvestorAccount}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{accounts}\PYG{p}{;}

    \PYG{k+kt}{address} \PYG{k+kr}{public} \PYG{n+nx}{profitDepositor}\PYG{p}{;}
    \PYG{k+kt}{uint} \PYG{k+kr}{public} \PYG{n+nx}{totalProfits}\PYG{p}{;}

    \PYG{c+c1}{// As long as the total supply isn\PYGZsq{}t fixed, i.e. new tokens can appear out of thin air,}
    \PYG{c+c1}{// the investors\PYGZsq{} profit shares aren\PYGZsq{}t determined.}
    \PYG{k+kt}{bool} \PYG{k+kr}{public} \PYG{n+nx}{totalSupplyIsFixed}\PYG{p}{;}
    \PYG{k+kt}{uint} \PYG{k+kr}{internal} \PYG{n+nx}{totalSupply\PYGZus{}}\PYG{p}{;}

    \PYG{k+kd}{event} \PYG{n+nx}{ProfitDepositorChanged}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{newProfitDepositor}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on profit deposited}
    \PYG{c+c1}{/// @param depositor An Ethereum address}
    \PYG{c+c1}{/// @param amount A positive number}
    \PYG{k+kd}{event} \PYG{n+nx}{ProfitDeposited}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{depositor}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{amount}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on profit share updated}
    \PYG{c+c1}{/// @param investor An Ethereum address}
    \PYG{c+c1}{/// @param amount A positive number}
    \PYG{k+kd}{event} \PYG{n+nx}{ProfitShareUpdated}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{investor}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{amount}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on profit withdrawal}
    \PYG{c+c1}{/// @param investor An Ethereum address}
    \PYG{c+c1}{/// @param amount A positive number}
    \PYG{k+kd}{event} \PYG{n+nx}{ProfitWithdrawal}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{investor}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{amount}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Ensure only depositor}
    \PYG{k+kd}{modifier} \PYG{n+nx}{onlyProfitDepositor}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender} \PYG{o}{==} \PYG{n+nx}{profitDepositor}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Constructor}
    \PYG{c+c1}{/// @param \PYGZus{}profitDepositor An Ethereum address}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}profitDepositor}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{setProfitDepositor}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}profitDepositor}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Change profit depositor}
    \PYG{c+c1}{/// @param \PYGZus{}newProfitDepositor An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{setProfitDepositor}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newProfitDepositor}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newProfitDepositor} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n+nx}{profitDepositor} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{\PYGZus{}newProfitDepositor} \PYG{o}{!=} \PYG{n+nx}{profitDepositor}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{emit} \PYG{n+nx}{ProfitDepositorChanged}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newProfitDepositor}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nx}{profitDepositor} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}newProfitDepositor}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Deposit profit}
    \PYG{k+kd}{function} \PYG{n+nx}{depositProfit}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{payable} \PYG{n+nx}{onlyProfitDepositor} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{totalProfits} \PYG{o}{=} \PYG{n+nx}{totalProfits}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{value}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{ProfitDeposited}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Profit share owing}
    \PYG{c+c1}{/// @param \PYGZus{}investor An Ethereum address}
    \PYG{c+c1}{/// @return A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{profitShareOwing}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}investor}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{uint}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{totalSupplyIsFixed} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{totalSupply\PYGZus{}} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}
               \PYG{o}{?} \PYG{n+nx}{totalProfits}\PYG{p}{.}\PYG{n+nx}{sub}\PYG{p}{(}\PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{lastTotalProfits}\PYG{p}{)}
                             \PYG{p}{.}\PYG{n+nx}{mul}\PYG{p}{(}\PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{)}
                             \PYG{p}{.}\PYG{n+nx}{div}\PYG{p}{(}\PYG{n+nx}{totalSupply\PYGZus{}}\PYG{p}{)}  \PYG{c+c1}{// \PYGZlt{}\PYGZhy{} The linter doesn\PYGZsq{}t like this.}
               \PYG{o}{:} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Update profit share}
    \PYG{c+c1}{/// @param \PYGZus{}investor An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{updateProfitShare}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}investor}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{totalSupplyIsFixed}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{uint} \PYG{n+nx}{additionalProfitShare} \PYG{o}{=}  \PYG{n+nx}{profitShareOwing}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{lastTotalProfits} \PYG{o}{=} \PYG{n+nx}{totalProfits}\PYG{p}{;}
        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{profitShare} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{profitShare}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{additionalProfitShare}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{ProfitShareUpdated}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{,} \PYG{n+nx}{additionalProfitShare}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Withdraw profit share}
    \PYG{k+kd}{function} \PYG{n+nx}{withdrawProfitShare}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{updateProfitShare}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{uint} \PYG{n+nx}{withdrawnProfitShare} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{profitShare}\PYG{p}{;}

        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{profitShare} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{.}\PYG{n+nx}{transfer}\PYG{p}{(}\PYG{n+nx}{withdrawnProfitShare}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{ProfitWithdrawal}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{withdrawnProfitShare}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{MintableToken}
\label{\detokenize{_contracts/MintableToken:mintabletoken}}\label{\detokenize{_contracts/MintableToken::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./ProfitSharing.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./Whitelisted.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title MintableToken}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{c+c1}{/// @dev A mintable token is a token that can be minted}
\PYG{k+kd}{contract} \PYG{n+nx}{MintableToken} \PYG{k+kr}{is} \PYG{n+nx}{ERC20}\PYG{p}{,} \PYG{n+nx}{ProfitSharing}\PYG{p}{,} \PYG{n+nx}{Whitelisted} \PYG{p}{\PYGZob{}}

    \PYG{k+kt}{address} \PYG{k+kr}{public} \PYG{n+nx}{minter}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on mint}
    \PYG{c+c1}{/// @param to An Ethereum address}
    \PYG{c+c1}{/// @param amount A positive number}
    \PYG{k+kd}{event} \PYG{n+nx}{Minted}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{to}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{amount}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Log entry on mint finished}
    \PYG{k+kd}{event} \PYG{n+nx}{MintFinished}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Ensure only minter}
    \PYG{k+kd}{modifier} \PYG{n+nx}{onlyMinter}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender} \PYG{o}{==} \PYG{n+nx}{minter}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Ensure can mint}
    \PYG{k+kd}{modifier} \PYG{n+nx}{canMint}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{o}{!}\PYG{n+nx}{totalSupplyIsFixed}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Ensure not minting}
    \PYG{k+kd}{modifier} \PYG{n+nx}{notMinting}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{totalSupplyIsFixed}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Set minter}
    \PYG{c+c1}{/// @param \PYGZus{}minter An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{setMinter}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}minter}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyOwner} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}minter} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{minter} \PYG{o}{==} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{minter} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}minter}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Mint}
    \PYG{c+c1}{/// @param \PYGZus{}to An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}amount A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{mint}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}amount}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyMinter} \PYG{n+nx}{canMint} \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{totalSupply\PYGZus{}} \PYG{o}{=} \PYG{n+nx}{totalSupply\PYGZus{}}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}amount}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}amount}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{Minted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}amount}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{emit} \PYG{n+nx}{Transfer}\PYG{p}{(}\PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}amount}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Finish minting}
    \PYG{k+kd}{function} \PYG{n+nx}{finishMinting}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{n+nx}{onlyMinter} \PYG{n+nx}{canMint} \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{totalSupplyIsFixed} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{MintFinished}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Minting finished}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{mintingFinished}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{totalSupplyIsFixed}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{SicosToken}
\label{\detokenize{_contracts/SicosToken:sicostoken}}\label{\detokenize{_contracts/SicosToken::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./MintableToken.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./KeyRecoverable.sol\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./Whitelisted.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title SicosToken}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{SicosToken} \PYG{k+kr}{is} \PYG{n+nx}{MintableToken}\PYG{p}{,} \PYG{n+nx}{KeyRecoverable} \PYG{p}{\PYGZob{}}

    \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{k+kd}{mapping}\PYG{p}{(}\PYG{k+kt}{address} \PYG{o}{=\PYGZgt{}} \PYG{k+kt}{uint}\PYG{p}{)}\PYG{p}{)} \PYG{k+kr}{internal} \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{;}

    \PYG{c+c1}{/// @dev Constructor}
    \PYG{c+c1}{/// @param \PYGZus{}whitelist An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}keyRecoverer An Ethereum address}
    \PYG{k+kd}{constructor}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}whitelist}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}profitDepositor}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}keyRecoverer}\PYG{p}{)}
        \PYG{k+kr}{public}
        \PYG{n+nx}{Whitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}whitelist}\PYG{p}{)}
        \PYG{n+nx}{ProfitSharing}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}profitDepositor}\PYG{p}{)}
        \PYG{n+nx}{KeyRecoverable}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}keyRecoverer}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Recover key}
    \PYG{c+c1}{/// @param \PYGZus{}oldAddress An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}newAddress An Ethereum address}
    \PYG{k+kd}{function} \PYG{n+nx}{recoverKey}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)}
        \PYG{k+kr}{public}
        \PYG{n+nx}{onlyKeyRecoverer}
        \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{)}
        \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Ensure that new address is *not* an existing account.}
        \PYG{c+c1}{// Check for account.profitShare is not needed because of following implication:}
        \PYG{c+c1}{//   (account.lastTotalProfits == 0) ==\PYGZgt{} (account.profitShare == 0)}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{lastTotalProfits} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{updateProfitShare}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{delete} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{KeyRecovered}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}oldAddress}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}newAddress}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Total supply}
    \PYG{c+c1}{/// @return A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{totalSupply}\PYG{p}{(}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{uint}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{totalSupply\PYGZus{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Balance of}
    \PYG{c+c1}{/// @param \PYGZus{}investor An Ethereum address}
    \PYG{c+c1}{/// @return A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{balanceOf}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}investor}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{uint}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Allowance}
    \PYG{c+c1}{/// @param \PYGZus{}investor An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}spender An Ethereum address}
    \PYG{c+c1}{/// @return A positive number}
    \PYG{k+kd}{function} \PYG{n+nx}{allowance}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}investor}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}spender}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{view} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{uint}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}investor}\PYG{p}{]}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}spender}\PYG{p}{]}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Approve}
    \PYG{c+c1}{/// @param \PYGZus{}spender An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}value A positive number}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{approve}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}spender}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}
        \PYG{k+kr}{public}
        \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{)}
        \PYG{n+nx}{notMinting}
        \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}spender}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{Approval}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}spender}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{k+kc}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Transfer}
    \PYG{c+c1}{/// @param \PYGZus{}to An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}value A positive number}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{transfer}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nx}{\PYGZus{}transfer}\PYG{p}{(}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Transfer from}
    \PYG{c+c1}{/// @param \PYGZus{}from An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}to An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}value A positive number}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{transferFrom}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)} \PYG{k+kr}{public} \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}value} \PYG{o}{\PYGZlt{}=} \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]} \PYG{o}{=} \PYG{n+nx}{allowance\PYGZus{}}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{[}\PYG{n+nx}{msg}\PYG{p}{.}\PYG{n+nx}{sender}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{sub}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{n+nx}{\PYGZus{}transfer}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{/// @dev Transfer}
    \PYG{c+c1}{/// @param \PYGZus{}from An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}to An Ethereum address}
    \PYG{c+c1}{/// @param \PYGZus{}value A positive number}
    \PYG{c+c1}{/// @return True or false}
    \PYG{k+kd}{function} \PYG{n+nx}{\PYGZus{}transfer}\PYG{p}{(}\PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{k+kt}{address} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{k+kt}{uint} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}
        \PYG{k+kr}{internal}
        \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{)}
        \PYG{n+nx}{onlyWhitelisted}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{)}
        \PYG{n+nx}{notMinting}
        \PYG{k+kr}{returns} \PYG{p}{(}\PYG{k+kt}{bool}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}to} \PYG{o}{!=} \PYG{k+kt}{address}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nb}{require}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}value} \PYG{o}{\PYGZlt{}=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{updateProfitShare}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{updateProfitShare}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{)}\PYG{p}{;}

        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{.}\PYG{n+nx}{sub}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance} \PYG{o}{=} \PYG{n+nx}{accounts}\PYG{p}{[}\PYG{n+nx}{\PYGZus{}to}\PYG{p}{]}\PYG{p}{.}\PYG{n+nx}{balance}\PYG{p}{.}\PYG{n+nx}{add}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kr}{emit} \PYG{n+nx}{Transfer}\PYG{p}{(}\PYG{n+nx}{\PYGZus{}from}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}to}\PYG{p}{,} \PYG{n+nx}{\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{k+kc}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{SampleToken}
\label{\detokenize{_contracts/SampleToken:sampletoken}}\label{\detokenize{_contracts/SampleToken::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kr}{pragma} \PYG{n+nx}{solidity} \PYG{l+m+mf}{0.4}\PYG{l+m+mf}{.23}\PYG{p}{;}

\PYG{k+kr}{import} \PYG{l+s+s2}{\PYGZdq{}./SicosToken.sol\PYGZdq{}}\PYG{p}{;}


\PYG{c+c1}{/// @title SicosToken}
\PYG{c+c1}{/// @author Autogenerated from a Dia UML diagram}
\PYG{k+kd}{contract} \PYG{n+nx}{SampleToken} \PYG{k+kr}{is} \PYG{n+nx}{SicosToken} \PYG{p}{\PYGZob{}}

    \PYG{k+kt}{string} \PYG{k+kr}{public} \PYG{n+nx}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}Sample Sicos Token\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{string} \PYG{k+kr}{public} \PYG{n+nx}{symbol} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}SAM\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kt}{uint} \PYG{k+kr}{public} \PYG{n+nx}{decimal} \PYG{o}{=} \PYG{l+m+mi}{18}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}